---
title: "Tutoriel d'initiation à R (Correction)"
author: "Carine Rey, Magali Naville & Marie Sémon"

date: "Dernière mise à jour: `r format(Sys.Date(), format = '%d %B %Y')`" 
output:
  #pdf_document:
  #  toc: true
  #  number_sections: true
  #  highlight: tango
  html_document:
    keep_md: true
    #code_folding: show
    theme: united
    highlight: tango
    toc: true
    toc_depth: 3
    number_sections: true
    toc_float:
      collapsed: true
      smooth_scroll: false
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  cache = F, tidy = T)
```

Le but de ces séances est d’apprendre à utiliser R dans des cas concrets, à produire un rapport reproductible, et à représenter des données avec R de manière optimale. Vous aborderez également l’analyse de données.

Il y aura 3 séances de 4h de TP consacrées à R. Ce document servira pour les 3 séances.

Il a été largement inspiré du site suivant (dans lequel vous pourrez également trouver (en anglais) des exemples d'application des tests statistiques du type de ceux que vous avez pratiqués en biostatistiques) : http://www.cyclismo.org/tutorial/R/, ainsi que de ce tutoriel en français : http://larmarange.github.io/analyse-R/.

Vous progresserez à votre rythme ; un autre document attendra ceux qui iront le plus vite !

# Objectifs du TP

A la fin de ces 3 séances de TP, vous devrez être capable de maîtriser tous les points énumérés ci-dessous :


* Faire une analyse reproductible en utilisant un fichier Rmarkdown (.Rmd)
    * Connaitre les bases de la syntaxe Markdown (md)
    * Rédiger un fichier .Rmd
    * Compiler un fichier .Rmd

* Savoir utiliser Rstudio
    * Savoir se déplacer dans l'arborescence de son ordinateur
    * Maitriser le concept de dossier de travail

* Importer des données provenant d'un fichier dans un tableau (data.frame)
    * .csv, .tsv (fichier texte, qui contient un tableau dont les colonnes sont espacées par des virgules ou des tabulations)
    * .xlsx (fichier Excel)

* Savoir explorer un tableau ou data.frame
    * Connaitre le nombre de lignes, de colonnes
    * Recupérer des statistiques récapitulatives : moyenne, minimum, maximum d'une ligne/colonne

* Manipuler les tableaux
    * Sélectionner une partie d'un tableau en fonction de critères
         * sur une colonne
         * sur une liste
    * Faire des opérations simples
         * Fusionner des tableaux
         * Rajouter une ligne ou une colonne qui contient le résultat d'un calcul (ex : somme ou moyenne d'une ligne/colonne)
    
 
* Maitriser les bases du language R :
    * Connaitre et savoir utiliser les différents types de base (nombre entier, chaine de caractères, facteur, vecteur, tableau, matrice, ...)
    * Savoir installer et charger des extensions (library)
    * Savoir écrire une fonction
    * Savoir maitriser les fonctions de la famille "apply"
    * Savoir utiliser des instructions (condition if, boucle for et while, ...)
    * Faire des graphiques
  

    
> Pas de panique,  les étudiants des années précedentes y sont arrivés ! De plus cette liste pourra faciliter vos révisions et vous aider à identifier les points à travailler.

#  Rstudio et le RMarkdown

# C'est parti !

# Importer des données

## Premier contact

> Puis créer de nouveaux chunks avec différentes opérations:

- soustraction : 259-57
- multiplication : 48*9
- division : 239/5

```{r}
259-57
48*9
239/5
```


> Dans un chunk, créez une variable "y" à laquelle vous assignerez le produit de 18 par 230.


```{r}
y<-18*230
y
```


##  Importer des valeurs manuellement


> Créez une variable 'petitourson' dans laquelle vous mettrez les valeurs 45.05, "youpie", et les chiffres 3 à 9. Affichez les valeurs de cette variable associées aux indices 2, 5 et 7.

```{r}
petitourson <-  c(45.05, "youpie", 3:9)
petitourson[c(2,5,7)]
```


## Importer des valeurs à partir d'un fichier

```{r}
heisenberg <- read.csv(file="data/exemples/simple.csv",head=TRUE,sep=",")
heisenberg
```


> Une autre manière d'importer les données d'un fichier est d'utiliser l'interface graphique de Rstudio (File > Import Dataset > From Csv), et de récupérer les lignes de commandes dans la section "code preview".

```{r}
library(readr)
simple <- read_csv("~/Documents/Enseignement/UE_bioinfo_L3/TP_R/2018/Poly/data/exemples/simple.csv")
simple
```



## Les extensions (library)

###  Présentation


###  Installation


## Exercices

Les données peuvent être lues dans une variable appelée "tree" en utilisant la commande read.csv. Allez-y !

```{r}
tree<-read.csv(file = "data/exemples/trees91.csv")
head(tree)
```


# Les structures élémentaires


## Les vecteurs


### Présentation des vecteurs


### Les principaux types de vecteurs

### Création

#### La fonction c

#### La fonction rep

> Créez un vecteur contenant la chaîne de caractère 'I love you' suivie de 3 fois la chaîne 'yeah', de la manière la plus élégante possible.

```{r}

y <- c('I love you', rep(c("yeah"), 3))

```


#### La fonction seq

> Créez un vecteur contenant une suite de valeurs de 50 à -50 avec un pas de -2.

```{r}
seq(50,-50, by = -2) 
```


#### L'opérateur ":"

### Longueur d'un vecteur

### Quelques vecteurs remarquables

### Combiner des vecteurs

### Valeurs manquantes

### Indexation des vecteurs

#### Indexation par position


```{r}
taille <- c(1.88, 1.65, 1.92, 1.76)
```

> Affichez toutes les valeurs d'indice pair contenues dans le vecteur "taille", de la manière la plus élégante possible.

```{r}
seq(2, length(taille), by=2)
taille[seq(0, length(taille), by=2)]
```

#### Indexation par nom

```{r}
sexe <- c(Michel = "h", Anne = "f", Dominique = NA, Jean = "h", Claude = NA, Marie = "f")
names(sexe) <- c("Michael", "Anna", "Dom", "John", "Alex", "Mary")
urbain <- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE)
poids <- c(80, 63, 75, 87, 82, 67)
anonyme <- unname(sexe)
```

#### Indexation par condition

> Affichez les noms des personnes de sexe masculin et de poids inférieur ou égal à 82 kgs.

```{r}
sexe

poids

is_masculin <- sexe == "h"
is_masculin

is_inf_82 <- poids <= 82
is_inf_82

is_masculin & is_inf_82 

is_not_na <- ! is.na(sexe)
is_not_na

is_masculin & is_inf_82 & is_not_na

names(sexe)

names(sexe)[is_masculin & is_inf_82 & is_not_na]

names(sexe)[sexe == "h" & ! is.na(sexe) & poids <= 82]
```


### Assignation par indexation

### Opérations sur les vecteurs

#### Opérations sur les vecteurs numériques


> Créez un vecteur "minus" comprenant les entiers impairs de 5 à 25. Créez un vecteur "cortex" de la même longueur que "minus" et comprenant une répétition de la valeur "-4". Créez un vecteur "hop" égal à racine(minus)-cortex³. Affichez le résumé de ce vecteur. Triez ses valeurs de manière décroissante.

```{r}

minus = seq(5,25,by=2)
minus

cortex = rep(-4, length(minus))
cortex

hop = sqrt(minus) - cortex ^2
hop

``` 


#### Opération sur les vecteurs de chaines de caractères

### En résumé

## Les listes (list)

### Propriétés et création


> Créez une liste "titi" contenant (avec des noms) votre prénom, la couleur de vos chaussettes, et le diamètre de votre cheville gauche. Créez la liste "rominet" contenant un vecteur contenant lui-même votre jour et votre année de naissance, et votre signe astrologique chinois. Combiner ces deux listes qui contiennent ces infos fondamentales.

```{r}
titi <- list(prenom = "mémé", chaussete = "jaune", "diam_cheville" = 48)

rominet <- list(jour_naissance = "1 avril", annee_naissance = 1937)

hector = c(titi, rominet)
hector
```


### Indexation

## Les tableaux de données (data frame)

### Propriétés et création


```{r}
df <- data.frame(
  sexe =  c("f", "f", "h", "h"), 
  age = c(52, 31, 29, 35), 
  blond = c(FALSE, TRUE, TRUE, FALSE),
  stringsAsFactors = FALSE
)
row.names(df) <- c("Anna", "Mary-Ann", "Michael", "John")
df
```

### Indexation


> Affichez l'âge de Anna.

```{r}

df["Anna","age"]
```


### Afficher les données

### Opérations sur les tableaux de données

```{r}
a <- data.frame(one=c( 0,1, 2),two=c("a","a","b"))
b <- data.frame(three=c(10,11,12,4),two=c("c","c","d","a"))
```


Pourquoi la ligne suivante produit-elle une erreur ?

```{r,eval=FALSE}
rbind(a,b) 
#les noms de colonnes de a et b sont différents
```


### En résumé


## Les matrices (matrix)

### Présentation et création



### Une matrice bien utile : les tables de contingence (table)

#### Tables de contingence à une dimension


#### Tables de contingence à deux dimensions

#### Conversion vers un data frame

## Les facteurs ou vecteurs avec modalités définies (factor)


### Présentation et création

## Pratiquons, pratiquons

### Vecteurs

> Créez un vecteur contenant les chiffres 1 à 6. Affichez la classe de ce vecteur.

```{r}
x <- 1:6
x
```

> Créez un vecteur contenant les noms de quelques uns de vos camarades. Affichez la longueur de ce vecteur. Affichez les 2 premiers camarades du vecteur. Affichez le 2ème et le 3ème. Classez le vecteur par ordre alphabétique, puis par ordre alphabétique décroissant.

```{r}
n = c("Titi","Mémé","Hector","Sylvestre")
length(n)
n[c(1,2)]

sort(n)
sort(n, decreasing = T)
```

> En utilisant les fonctions rep() et seq(), créez le vecteur 'a','a',1,2,3,4,5,7,9,11.

```{r}
c(rep("a",2), seq(1,4), seq(5,11,by=2))
```

> Supprimez les valeurs manquantes du vecteur c(1,2,NA,4).

```{r}
x <- c(1,2,NA,4)
y <- x[ ! is.na(x)]
y
```

> * Créez un vecteur de 50 valeurs choisies aléatoirement et avec remise entre 1 et 100.

```{r}
x <- sample(1:100, size = 50, replace = T)
x
# Il y a bien des nombres qui ont été tirés plusieurs fois
table(sort(x))
```


> * Calculez la somme cumulative des valeurs du vecteur précédent.

```{r}
cumsum(x)
```

> * Créez la chaîne de caractère 'Les chaussettes de l'archiduchesse sont elles seches ou archi-seches'. Séparez-la en différentes sous-chaînes délimitées par le caractère 'e'. Lisez distinctement le résultat à votre voisin.

```{r}
x <- "Les chaussettes de l'archiduchesse sont elles seches ou archi-seches"
strsplit(x,split = "e")

```


### Tableaux de données

> Nous allons ici utiliser un jeu de données disponible sur R, 'iris'. Affichez la classe de ce jeu de données. Affichez le résumé du tableau de données. Affichez les 6 premières lignes du tableau. Affichez le tableau dans Rstudio. Affichez les noms des lignes, puis les noms des colonnes. Affichez le nombre de lignes et de colonnes.

```{r}
data("iris")
iris
class(iris)
summary(iris)
head(iris)
iris[1:6,]
#View(iris)
rownames(iris)
colnames(iris)
dim(iris)
nrow(iris)
ncol(iris)
```

> Affichez la 8ème ligne du tableau, puis la valeur de la 12ème ligne et 3ème colonne.

```{r}
iris[8,]
iris[12,3]
```

> Affichez les longeurs des pétales pour les lignes 10 à 15.

```{r}

iris$Petal.Length[10:15]
iris[10:15, "Petal.Length"]
```

> Affichez les longeur et largeur des sépales pour la ligne 38.

```{r}
iris[38, c("Sepal.Width", "Sepal.Length")]
```

> Affichez les numéros de ligne pour lesquelles la largeur des pétales est supérieure à 1.8.

```{r}
rownames(iris)[iris$Petal.Width > 1.8]
which(iris$Petal.Width > 1.8)
```

> Affichez les espèces pour lesquelles la longueur des sépales est supérieure à 5 et inférieure à 6.

```{r}
unique(iris$Species[iris$Sepal.Length > 5 & iris$Sepal.Length < 6])
```

> Créez une table de contingence des largeurs de sépales et espèces.

```{r}
t = table(iris$Species, iris$Sepal.Width)
t
as.data.frame.matrix(t)
```

# Graphiques de base

## Histogramme

> A partir de jeu de données "iris", tracez l'histogramme de la largeur des pétales. Indiquez le nom de l'axe des abscisses et ajoutez un titre. Ajouter un stripchart au-dessus de l'histogramme.

```{r}
hist(iris$Petal.Width,main='Titre',xlab='Petal.Width')
stripchart(iris$Petal.Width,add=TRUE,at=-0.5)
``` 

## Boxplots 

## Scatter Plots

# Application sur un premier vrai jeu de données (les chauves-souris)

> Récupérer le jeu de données sur le portail des études (chauves-souris-fellatio-data.txt) et l'importer.

```{r}
chauvesouris=read.csv(file='data/appli1/chauves_souris_data.txt',head=T, sep=" ")
```


> Quelle commande permet d’obtenir l’affichage des 7 premières lignes du jeu de données ?

```{r}
head(chauvesouris,7)
chauvesouris[1:7,]
```

> Quelle commande permet d’obtenir le nombre de lignes et de colonnes de votre table ?

```{r}
dim(chauvesouris)
ncol(chauvesouris)
nrow(chauvesouris)
```

> Quelle commande permet d’obtenir le nom des colonnes de votre table ?

```{r}
colnames(chauvesouris)
#pour les lignes
rownames(chauvesouris)
```


> Quelle commande permet d’obtenir la moyenne des temps de copulation pour toutes les données ?

```{r}
mean(chauvesouris$time_copulation)
mean(chauvesouris$time_copulation, na.rm = T)
```

> Quelles commandes permettent de créer deux nouveaux tableaux, un pour chaque comportement ?

```{r}
lick1<- chauvesouris[chauvesouris$licking != 0,]
lick0<- chauvesouris[chauvesouris$licking != 1,]
head(lick1)

lick1<- chauvesouris[which(chauvesouris$licking != 0),]
lick0<- chauvesouris[which(chauvesouris$licking != 1),]
head(lick1)

lick1 <- subset(chauvesouris, licking == 1)
lick0 <- subset(chauvesouris, licking == 0)
head(lick1)
```

> Quelle commande permet de selectionner les lignes telles que le temps de copulation soit supérieur à 100 ?

```{r}
subset(chauvesouris, time_copulation>100)
chauvesouris[chauvesouris$time_copulation>100,]
chauvesouris[which(chauvesouris$time_copulation>100),]
```

> Quelle commande permet de selectionner les lignes telles que le temps de copulation soit supérieur à 200 et le temps de léchage inférieur ou égal à 20 ?

```{r}
subset(chauvesouris, time_copulation>200 & time_licking<=20)
chauvesouris[chauvesouris$time_copulation>200 & chauvesouris$time_licking<=20,]
chauvesouris[which(chauvesouris$time_copulation>200 & chauvesouris$time_licking<=20),]
```

> Quelle commande permet de récupérer le temps de copulation dans le cas où le temps de léchage est supérieur à 20 ?

```{r}
chauvesouris$time_copulation[chauvesouris$time_licking>20]
```

> Quelle commande permet d’obtenir la moyenne des temps de copulation par comportement ?

```{r}
tapply(chauvesouris$time_copulation, chauvesouris$licking, mean)
```

> Donner deux commandes permettant de savoir dans combien de cas le comportement de léchage a été observé.

```{r}
table (chauvesouris$licking)
tapply(chauvesouris$licking,chauvesouris$licking,length)
```

Dans l’étude, les chercheurs ont commencé par regarder s’il existait une relation entre le temps de léchage et le temps de copulation total.

> Donner la commande permettant de tracer ce graphique, sans oublier les légendes.

```{r}
plot(chauvesouris$time_licking,chauvesouris$time_copulation, xlab="Time licking", ylab="Time copulation")
```

> Rajouter une droite de régression sur ce graphique.

```{r}

# ATTENTION lm(y~x) et plot(x,y)

reg=lm(chauvesouris$time_licking~chauvesouris$time_copulation)
reg

plot(x=chauvesouris$time_copulation, y=chauvesouris$time_licking, xlab="Time licking", ylab="Time copulation")
abline(reg, col='red' )
```


Le coefficient de corrélation entre le temps de léchage et le temps de copulation (calculé sur l’ensemble des données) vaut R = 0.86, et un test statistique montre que cette valeur est significativement différente de 0.

> Recalculer la valeur du coefficient de corrélation et refaire le test. Pourquoi les chercheurs ne peuvent-ils pas en déduire que le phénomène de léchage est la cause d’un temps de copulation plus long ? (Réponse simple attendue)

```{r}
cor(chauvesouris$time_licking, chauvesouris$time_copulation)
cor.test(chauvesouris$time_licking,chauvesouris$time_copulation)

## Corrélation != Causalité
```

> Quel graphe feriez-vous pour illustrer la différence des temps de copulation entre les couples où l’on observe le phénomène de léchage et les couples où on ne l’observe pas ? Donner la (ou les) commande(s) correspondante(s).

```{r}
boxplot(chauvesouris$time_copulation~chauvesouris$licking, xlab = "Licking")
```


# Graphiques intermédiaires


## Données continues


```{r}
x <- rnorm(100,sd=5,mean=20)
y <- 2.5*x-1.0+rnorm(100,sd=9,mean=0) # ERREUR ENONCE 10 -> 100
plot(x,y)
cor(x,y)
```


### Plusieurs jeux de données sur un graphique


```{r}
x <- rnorm(50,sd=5,mean=20)
y <- 2.5*x - 1.0 + rnorm(10,sd=9,mean=0) # ERREUR ENONCE 10 -> 50

plot(x,y,xlab="Independent",ylab="Dependent",main="Random Stuff")
x1 <- runif(25,15,25)
y1 <- 2.5*x1 - 1.0 + runif(8,-6,6) # ERREUR ENONCE 8 -> 25
points(x1,y1,col=2)
```

### Barres d'erreur 


### Plusieurs graphiques sur une image


### Tracés de densité

### Colorier des régions


## Données discrètes

### Barplot


## Sauvegarder un graphique dans un fichier

## Pratiquons, pratiquons

> Importer à nouveau le jeu de données `tree` dans "data/exemples/trees91.csv"

```{r}
tree = read.csv(file="data/exemples/trees91.csv",sep=",",head=TRUE)
head(tree)
```

> Sur un même graphique représenter la biomasse des tiges de l'arbre (6e colonne) en fonction de la concentration en Nitrate (N) (9e colonne) dans les tiges en colorant de manière différente les points en fonction de l'exposition au dioxyde de carbone (1e colonne). Ajouter la légende.

Proposition 1 : 

```{r}
plot(tree[,9][tree$C==1],tree[,6][tree$C==1], xlab="Concentration en Nitrate", ylab="Biomasse des tiges de l'arbre", xlim=c(min(tree[,9]),max(tree[,9])), ylim=c(min(tree[,6]),max(tree[,6])), col=1)
points(tree[,9][tree$C==2],tree[,6][tree$C==2],col=2)
points(tree[,9][tree$C==3],tree[,6][tree$C==3],col=3)
points(tree[,9][tree$C==4],tree[,6][tree$C==4],col=4)
```
```{r}
plot(tree$STNCC,tree$STBM, main='Biomasse des tiges en fonction\nde la concentration en nitrate', col=tree$C)
legend(1.15,0.7,c("C=1", "C=2", "C=3", "C=4"), col=1:4, pch=1)
```

> Faire un graphe pour représenter le nombre d'arbres dans chacune des catégories d'exposition au dioxyde de carbone (1e colonne).


Proposition 1 :

```{r}
barplot(table(tree$C),main="Nombre d'arbre en fonction de l'exposition au CO2",ylab="Nombre d'arbres")
```

Proposition 2 :

```{r}
effectif=tapply(tree$C, tree$C, length)

barplot(effectif,main="Nombre d'arbre en fonction de l'exposition au CO2", xlab="Catégorie d'exposition au CO2", ylab="Nombre d'arbres")

```

Proposition 3 :

```{r}
freqtree= table(tree[,1])
freqtree
rownames(freqtree) <- c("one","two","three","four")
barplot(freqtree, main ="Répartition", ylab="nombre d'arbres", xlab="Tx exposition C")
```

> Faire un graphe pour représenter la distribution de la biomasse des tiges de l'arbre (6e colonne) en fonction de l'exposition au dioxyde de carbone (1e colonne).

Proposition 1 :

```{r}
boxplot(tree[,6]~tree$C, main="Distribution de la biomasse des tiges\nen fonction de l'exposition au CO2",xlab="Catégories d'exposition au CO2", ylab="Distribution de la biomasse des tiges")
```

 
# Introduction à la programmation

## Instructions de base

### if 


> Créez une variable contenant la chaîne de caractère de votre choix. A l'aide de l'instruction `if`, testez si cette chaîne contient la lettre "a". Si oui, écrivez "bingo!".

```{r}
var="Il va être l'heure de partir"
var1=gsub("a","i",var)
if  (var!=var1)
  {
    print("Bingo")
  }
```



### for


> Créer une variable initiée à la valeur 0. A l'aide d'une boucle `for`, ajoutez lui tous les multiples de 5 entre 0 et 100. Affichez le résultat.

Proposition 1 :

```{r}
var=0
for (k in seq(0,100,by=5)) {
    var=var+k
}
print(var)
```




### while


> Créer une variable initiée à la valeur 2. Tant qu'elle est inférieure à 2048, multipliez-là par deux. Affichez le nombre de multiplications que vous avez fait.

Proposition 1 :
```{r}
var=2
compteur=0
while(var<2048)
{
    var=var*2
    compteur=compteur+1
    cat("v=", var, "i:", compteur, "\n")
}
print(compteur)
```


## Les fonctions

### Présentation

### Arguments des fonctions 

### Pratiquons, pratiquons

#### Exercice 1

> Faire une fonction "paire" qui prend un nombre x, et renvoie TRUE ou FALSE si ce nombre est pair.

* Proposition 1 :

```{r}
paire <- function(x)
{
  if (x%%2 == 0)
  {
    return(TRUE)
  } else
  {
    return(FALSE)
  }
}
```

 * Proposition 2 : 
 
```{r}
paire <- function(x) {
  return (x%%2 == 0)
}
```


```{r ,eval=T}
paire(2)
paire(5)
paire(2.3)
```

> Faire une fonction "somme_carre"" qui prend 2 nombres x et y, et renvoie la somme des carrés de ces 2 nombres.

Proposition 1 :

```{r ,eval=T}

somme_carre <- function(x,y) 
  {
  return(x**2 + y**2)
}
```

```{r ,eval=T}
somme_carre(2,563)
somme_carre(7,95)
somme_carre(-2, 4)
```


> Faire une fonction qui trace un histogramme, l'enregistre en pdf, en mettant la couleur et le titre en option. 

http://rfunction.com/archives/812

```{r}
    trace_histo <- function(x,file="histo.pdf", titre = 'Title', couleur = 1) {
      pdf(file)
      hist(x, col = couleur, main = titre)
      dev.off()
}
```

```{r ,eval=F}
x=runif(1000)
trace_histo(x, file="histo.pdf",titre="Super titre",couleur="red")
```


> Faire une fonction "filtre_positif" qui prend un vecteur de nombres, et renvoie les valeurs positives.

```{r ,eval=F}
filtre_positif <- function(x)
{ return(x[x>0])    
}
filtre_positif(c(-2,3,9,-1,5))
```


#### Exercice 2

> Créer	une	séquence d'ADN aléatoire de	1000 nucléotides. Combien de	fois est présent chaque	nucléotide ?	

```{r ,eval=T}
sequence_ADN_compte<-function() {
  seq_nt=sample(c("A","T","G","C"),1000,replace=T)
  return(table(seq_nt))
}

sequence_ADN_compte()
```

> Lancer cette fonction 1000 fois et représenter la distribution du nombre de "A". Ajouter une verticale sur le graphique qui montre la moyenne attendue. Mettre un titre.
  	
  	
```{r}
generation_seq<-function(n) {
  seq_nt=sample(c("A","T","G","C"),n,replace=T)
  return(seq_nt)
}

freq <- c()
for (k in seq(1,1000))
{
  freq <- c(freq,table(generation_seq(1000))[1])
}
hist(freq,col = 'red', main = 'Distribution du nombre de A\ndans une séquence de 1000 bases', xlab = 'Nombre de A')
abline(v = 250, col = 'green')
```




> Encapsuler la manip précédente dans une fonction, qui prend le nucléotide demandé en argument, une couleur pour le graphique et le sauve.


```{r}
generation_seq<-function(n) {
  seq_nt=sample(c("A","T","G","C"),n,replace=T)
  return(seq_nt)
}

hist_nt_X <- function(nt = "A" , couleur = "blue") {
  freq <- c()
  for (k in seq(1,1000)){
      freq <- c(freq,table(generation_seq(1000))[nt])
  }
  hist(freq, col = couleur, main = paste('Distribution du nombre de', nt, '\ndans une séquence de 1000 bases'), xlab = paste('Nombre de A'))
  abline(v = 250, col = 'green')
}

hist_nt_X()
```

```{r}
generation_seq<-function(n) {
  seq_nt=sample(c("A","T","G","C"),n,replace=T)
  return(seq_nt)
}

hist_nt_X <- function(nt = "A" , couleur = "blue") {
  freq = sapply(1:1000, function(x) {table(generation_seq(1000))[nt]})
  hist(freq, col = couleur, main = paste('Distribution du nombre de', nt, '\ndans une séquence de 1000 bases'), xlab = paste('Nombre de A'))
  abline(v = 250, col = 'green')
}

hist_nt_X()
```




> Appliquer cette fonction pour tous les nucléotides.

```{r}
hist_nt_X("A","red")
hist_nt_X("T","green")
hist_nt_X("G","blue")
hist_nt_X("C","orange")
```


```{r}
sapply(c("A","T","G","C"), hist_nt_X)
```

### Precicions sur les fonctions


#### L’argument spécial point-point-point

#### Illustration de la neutralisation de l’affichage automatique dans les fonctions

#### Détermination de la valeur d'une variable dans une fonction

### La famille des fonctions apply (comment faire une boucle en R)


#### Opérations sur les listes et les vecteurs


> Faire une fonction qui renvoie la somme des carrée d'une liste de nombres.

```{r, eval=TRUE}
somme_carre_list <- function( lili ) {
  sum(sapply(lili, function(x){x**2}))
}

somme_carre_list(list(1,2,3,4,5,6))

```


#### Opérations groupées par modalités d'un facteur

#### Opérations sur un tableau

La fonction apply prend un tableau, et une fonction. Elle peut appliquer la fonction soit sur les lignes, soit sur les colonnes, soit sur les deux ; par exemple elle permet de calculer la somme d'un tableau ligne par ligne ou colonne par colonne. 

```{r,eval=TRUE}
val <- data.frame(a=runif(5,1,10),
                    b=runif(5,1,10),
                  c=runif(5,1,10))
val

val$mean = apply(val,1,mean)

val

val["total",] = apply(val,2,sum)
val

```

> Faire la meme chose sur val2.

```{r, eval=TRUE}
val2 <- data.frame(name=LETTERS[1:5],
                  a=runif(5,1,10),
                    b=runif(5,1,10),
                  c=runif(5,1,10),
                  stringsAsFactors = F) 
val2

val2$mean = apply(val2[,2:ncol(val2)],1,mean)

val

val2[nrow(val2)+1,] = c("total", apply(val2[,2:ncol(val2)],2,sum))
val2
```

### Pratiquons, pratiquons

#### Exercice 3

> Chargez le tableau 'iris'. Créez un vecteur contenant autant d'éléments que de lignes dans le tableau, dans lequel vous placerez la chaîne "plus grand que 5" si la longueur des sépales est supérieure à 5, et la chaîne "moins grand que 5" dans le cas contraire. Faites le de deux manières différentes, à l'aide d'une boucle for.

```{r}
data(iris)
head(iris)

x=rep("", nrow(iris))
for (i in seq(1, nrow(iris))) {
  if (iris$Sepal.Length[i]>5) {
    x[i]='plus grand que 5'
  } else {
    x[i]='moins grand que 5'
  }  
}
x

sapply(iris$Sepal.Length,function(x){
  if (x>5)
  {
      return("Plus grand que 5")
  }else 
  {
      return("Moins grand que 5")
  }
}
)

l=rep(0, nrow(iris))
l[iris[,"Sepal.Length"]>=5]='plus grand que 5'
l[iris[,"Sepal.Length"]<5]='moins grand que 5'
l
```



#### Exercice 4

> Reprenez l'exercice précédent en utilisant cette fois-ci la fonction "apply".


```{r}
data(iris)
head(iris)

sapply(iris$Sepal.Length,function(x){
  if (x>5)
  {
      return("Plus grand que 5")
  }else 
  {
      return("Moins grand que 5")
  }
}
)

```

> Pour chaque fleur, calculez, à l'aide de "apply", le produit de la longueur des pétales par leur largeur.

```{r}
data(iris)
head(iris)

surface_petale = apply( iris[, c('Petal.Length',"Petal.Width")],1,function(x){x[1]*x[2]})
surface_petale

#On est d'accord que cette question est complètement artificielle et que faire 
surface_petale2 =  iris$Petal.Length * iris$Petal.Width # est plus rapide

# On peut vérifier le nombre de fois ou les valeurs sont identiques (toutes ! ouf !)
table(surface_petale == surface_petale2)

```



## Exécuter un fichier

### Exécuter les commandes dans un fichier

# Application sur un second jeu de données (lézards)

> Importer le jeu de données contenu dans "data/appli2/lezard_per_pop.csv" et afficher les 5 premières lignes.

```{r, eval=TRUE} 
lezard = read.csv("data/appli2/lezard_per_pop.csv", sep = "\t", stringsAsFactors = F) #  "data/appli2/lezard_per_pop.csv" == "data/appli2/lezard.csv"
head(lezard,5)
``` 


> Calculer le nombre de populations (colonne "poblacio" dans la table), le nombre total de femelles, le nombre total de mâles, le nombre total d'individus.
  
```{r, eval=TRUE} 

P_nb=length(lezard$poblacio)
P_nb
F_nb = sum(lezard$females)
F_nb
M_nb = sum(lezard$males)
M_nb
N_nb = sum(lezard$N)
N_nb


``` 


> Construire une nouvelle colonne contenant le sex ratio pour chacune des populations. Quels sont le minimum, la moyenne et le maximum  des sex ratio observés dans les populations ? 

$$ Sex ratio = \frac{Nb_{male}}{Nb_{femelle}} $$


```{r, eval=TRUE} 
lezard$sex_ratio = lezard$males/lezard$females
head(lezard)
``` 


> Restreindre votre jeu de données aux populations qui ont 50 lézards ou plus. Quelles populations passent le seuil ?

```{r, eval=TRUE} 
lezard$poblacio[lezard$N >= 50]
lezard =  lezard[lezard$N >= 50,]
``` 

> Représenter en fonction du nombre de morphes (colonne "richness") la distribution des sex ratio. Qu'est-ce que vous observez ?

```{r}
boxplot(lezard$sex_ratio ~ lezard$richness)
```

> Représenter la « régularité » de la répartition du nombre d'individus entre les morphes (eveness) en fonction du sex ratio. Ajouter sur le graphe une droite de tendance. Que pouvez-vous conclure ?

```{r}
plot(lezard$evenness ~ lezard$sex_ratio)
abline(lm(lezard$evenness ~ lezard$sex_ratio), col="red")


```


> Importer maintenant le jeu de données contenu dans "data/appli2/lezard_per_ind.csv". Il contient les caractéristiques (populations, morph, sexe) de chaque individu. Calculer le nombre de morphe pour chacun des sexes par population.


```{r}
lezard2 = read.csv("data/appli2/lezard_per_ind.csv", head=T, stringsAsFactors = F)
lezard2 = lezard2[lezard2$pop %in% lezard$poblacio,]
head(lezard2)

lezardM = lezard2[lezard2$sexe == "M",]
lezardF = lezard2[lezard2$sexe == "F",]
nb_morphe_M = tapply(lezardM$morphe, lezardM$pop, function (x) { return((length(unique(x))))})
nb_morphe_F = tapply(lezardF$morphe, lezardF$pop, function (x) { return((length(unique(x))))})


head(nb_morphe_M)
head(nb_morphe_F)
```


L'indice de shannon est un indice permettant de mesurer la diversité spécifique. 
Sa formule est:

$$ S = - \sum \limits_{i=1}^n p_i ln(p_i)$$ avec $n$ le nombre de morphes dans la population et $p_i$  la proportion du $i^{eme}$ morphe dans la population


> Faire une fonction pour calculer cet indice puis calculez-le pour chacune des populations.

```{r}
shannon <- function(x) {
  p = table(x)/length(x)
  p=p[p>0]
  s = -sum(p * log(p))
  return(s)
}

calc_by_pop = function (df) {
    return(tapply(df$morphe, df$pop, shannon))
}
        
```


> Avez vous bien utilisé la famille apply, et la fonction "table" ? Sinon, corrigez les lignes suivantes pour le faire :

> Représenter l'indice de shannon en fonction du sex ratio. Ajouter sur le graphe une droite de tendance. Que pouvez vous conclure ?

```{r} 
shannon_pop = calc_by_pop(lezard2)
lezard$shannon_MF = shannon_pop[lezard$poblacio] ## ATTENTION, à l'ordre des population
plot(lezard$shannon_MF  ~ lezard$sex_ratio, ylim = c(0,max(shannon_pop)+1))
abline(lm(lezard$shannon_MF  ~ lezard$sex_ratio), col  = "red")

summary(lm(lezard$shannon_MF  ~ lezard$sex_ratio))

``` 

```{r} 
make_plot_lm <- function (df_pop, df_ind) {
  shannon_pop = calc_by_pop(df_ind)
  df_pop$shannon = shannon_pop[df_pop$poblacio]
  plot(df_pop$shannon ~ df_pop$sex_ratio, ylim = c(0,max(df_pop$shannon)+1), xlim = c(0,max(df_pop$sex_ratio)+0.1))
  abline(lm(df_pop$shannon ~ df_pop$sex_ratio), col  = "red")
  summary(lm(df_pop$shannon ~ df_pop$sex_ratio))
}

make_plot_lm(lezard, lezard2)
``` 
> Faire de-même en calculant l'indice de shannon par sexe. Que pouvez vous conclure ?

```{r} 
print("F")
make_plot_lm(lezard, lezard2[lezard2$sexe == "F",])
print("M")
make_plot_lm(lezard, lezard2[lezard2$sexe == "M",])

``` 

# Application sur un troisième jeu de données (les abeilles) et initiation à ggplot2

Correction sur demande
