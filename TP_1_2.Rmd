---
title: "Tutoriel initiation à R"
author: "Carine & Marie"

date: "Dernière mise à jour: `r format(Sys.Date(), format = '%d %B %Y')`" 
output:
  #pdf_document:
  #  toc: true
  #  number_sections: true
  #  highlight: tango
  html_document:
    keep_md: true
    #code_folding: show
    theme: united
    highlight: tango
    toc: true
    toc_depth: 3
    number_sections: true
    toc_float:
      collapsed: true
      smooth_scroll: false
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results="hide", fig.keep = "none")
```


Le but de ces séances est d’apprendre à utiliser R dans des cas concrets, à produire un rapport reproductible, et à représenter des données avec R de manière optimale. Vous aborderez également l’analyse
de données.

R est déja installé sur les ordinateurs des salles de TP. Pour l’installer sur votre ordinateur personnel, voir
la page du CRAN http://cran.r-project.org/bin/. R est installé par défaut avec des fonctions de la
library base. Vous devrez également installer RStudio pour faire les rapports de TP. https://www.rstudio.com/products/rstudio/download/

Le tutoriel est largement inspiré du site suivant, dans lequel vous pourrez également trouver (en anglais) des exemples d'application des tests statistiques du type de ce que vous avez pratiqué en biostatistiques. http://www.cyclismo.org/tutorial/R/

# Importer des données

En premier lieu, nous allons importer des données dans une session R. Il y a plusieurs façons de lire des données dans une session R, mais nous nous concentrons sur deux seulement pour rester simple.

##  Affectation simple

La façon la plus simple de stocker des nombres est d'utiliser la commande c (pour «combiner»). Un vecteur de nombres est stocké sous un nom donné, et le nom est utilisé pour faire référence aux données. Le vecteur est spécifié avec la commande c, et l'affectation est spécifié avec le symbole "<-". 
Les nombres dans la commande c sont séparés par des virgules. A titre d'exemple, nous pouvons créer une nouvelle variable, appelée "bubba" qui contiendra les numéros 3, 5, 7 et 9:

```{r}
bubba <- c(3,5,7,9)
```

Lorsque vous entrez cette commande, vous ne devriez voir aucune sortie sauf un ">" indiquant un appel à une nouvelle ligne de commande. La commande a pourtant créé une liste de nombres appelés "bubba". Pour voir quels numéros sont inclus dans bubba tapez "bubba" et appuyez sur la touche Entrée:

```{r}
bubba 
```

Si vous souhaitez travailler avec l'un des nombres stocker, vous pouvez y accéder en utilisant la variable, puis les crochets indiquant l'indice:

```{r}
bubba[2]
bubba[1]
bubba[0]
```

Notez que la première entrée correspond au numéro 1 et que le zéro peut être utilisé pour indiquer comment l'ordinateur traitera les données. Vous pouvez stocker des chaînes de caractère à l'aide de guillemets simples et doubles, et vous pouvez stocker des nombres réels.


##  Lecture de fichiers

Il est rare d'avoir juste quelques points de données. Il est beaucoup plus commun d'avoir beaucoup de données avec des relations compliquées. Ici, nous allons examiner comment lire un jeu de données à partir d'un fichier, mais nous devons d'abord discuter du format d'un fichier de données.

Nous supposons que le fichier de données est au format appelé "comma separated values" (csv). C'est-à-dire que chaque ligne contient une rangée de valeurs qui peuvent être des nombres ou des lettres, et chaque valeur est séparée par une virgule. Nous supposons également que la toute première rangée contient une liste d'étiquettes qui font référence aux différentes colonnes de valeurs.

La commande pour lire un fichier de données est read.csv. Nous devons donner à la commande au moins un argument (le nom du fichier), mais nous allons donner deux arguments optionnels supplémentaires. Le premier argument indique si la première ligne contient les noms des colonnes. Le deuxième argument indique qu'il y a une virgule entre chaque numéro de chaque ligne. La commande suivante va lire dans les données et l'assigner à une variable appelée "heisenberg". Lorsque vous utilisez la commande read.csv, R utilise un type spécifique de variable appelé "data frame". Toutes les données sont stockées sous la forme de colonnes séparées. 

```{r}
heisenberg <- read.csv(file="simple.csv",head=TRUE,sep=",")
heisenberg
summary(heisenberg)
```

Pour obtenir plus d'informations sur les différentes options disponibles, vous pouvez utiliser la commande help:

```{r}
?read.csv
```

Si R ne trouve pas le fichier que vous essayez de lire, il se peut qu'il recherche dans le mauvais dossier / répertoire. Si vous utilisez l'interface graphique, vous pouvez modifier le répertoire de travail. Si vous n'êtes pas sûrs des fichiers qui se trouvent dans le répertoire de travail actuel, vous pouvez utiliser la commande dir() pour lister les fichiers et la commande getwd() pour déterminer le répertoire de travail actuel:

```{r}
dir()
getwd()
```

Si vous n'utilisez pas l'interface graphique, alors on peut changer de répertoire de travail avec setwd(), en indiquant le nouveau répertoire entre guillemets dans la parenthèse.

La variable "heisenberg" contient les trois colonnes de données. Chaque colonne reçoit un nom basé sur l'en-tête (la première ligne du fichier). Vous pouvez maintenant accéder à chaque colonne en utilisant un "$":

```{r}
heisenberg$trial
heisenberg$mass
heisenberg$velocity
```

Si vous n'êtes pas sûr des colonnes contenues dans la variable, vous pouvez utiliser la commande names:

```{r}
names(heisenberg)
```


Nous allons étudier un autre exemple tout au long de ce tutoriel. Le fichier de données a été créé par un groupe à Oak Ridge National Laboratory. Les données d'origine sont données dans une feuille de calcul Excel, et le fichier CSV a été créé en supprimant l'ensemble supérieur de lignes et en l'enregistrant comme un fichier "csv". Ceci est une option pour enregistrer dans Excel. Vous devrez enregistrer le fichier sur votre ordinateur.

La feuille de calcul d'origine se trouve à l'adresse http://cdiac.ornl.gov/ftp/ndp061a/trees91.wk1. Une description du fichier de données se trouve à http://cdiac.ornl.gov/ftp/ndp061a/ndp061a.txt.

Les données contiennent des estimations de la biomasse de pin ponderosa dans une étude réalisée par Dale W. Johnson, J. Timothy Ball et Roger F. Walker (Université du Nevada). La table contient 54 lignes, et chaque ligne représente une observation. Chaque observation comprend des mesures et des marqueurs pour 28 mesures différentes d'un arbre donné. Par exemple, le premier chiffre de chaque rangée est un nombre, 1, 2, 3 ou 4, qui indique un niveau différent d'exposition au dioxyde de carbone. Le sixième nombre dans chaque rangée est une estimation de la biomasse des tiges d'un arbre. Notez que la toute première ligne du fichier est une liste d'étiquettes utilisées pour les différentes colonnes de données.

Les données peuvent être lues dans une variable appelée "tree" en utilisant la commande read.csv. Allez-y!

```{r}

#ajouter ici les commandes pour lire le fichier tree91
#tree<-

```

Cela créera une nouvelle variable appelée "tree". Si vous tapez "tree" à l'invite et appuyez sur Entrée, tous les éléments stockés dans la variable seront imprimés. Essayez!




# Types de données de base 

## Types de variables

### Numeriques (numeric)

 
```{r}
a <- 3
```

Le "<-" dit à R de prendre le numéro à droite du symbole et de le stocker dans une variable dont le nom est donné à gauche. Vous pouvez également utiliser le symbole "=". Lorsque vous effectuez une tâche, R n'imprime aucune information. Si vous voulez voir quelle valeur une variable vient de taper le nom de la variable sur une ligne et appuyez sur la touche Entrée:

```{r}
a
```

Cela vous permet de faire toutes sortes d'opérations de base et d'enregistrer les valeurs:


```{r}
b <- sqrt(a *a +3)
b
```

Si vous voulez obtenir une liste des variables que vous avez définies dans une session particulière, vous pouvez les lister toutes en utilisant la commande ls:

```{r}
ls()
```


Vous n'êtes pas limité à simplement enregistrer un seul numéro. Vous pouvez créer un "vecteur" en utilisant la commande c:

```{r}
a<-c(1,2,3,4,5)
a
```


```{r}
a +1
```

```{r}
mean(a)
```

```{r}
var(a)
summary(a)
```


Vous pouvez accéder à des entrées particulières dans le vecteur de la manière suivante:

```{r}
a <- c(1,2,3,4,5)
a[1]
a[2]
a[0]
a[5]
a[6]
```

La première entrée dans le vecteur est le premier nombre, et si vous essayez d'obtenir un nombre après le dernier nombre, vous obtenez "NA".
Pour initialiser une liste de nombres, la commande numérique peut être utilisée. Par exemple, pour créer une liste de 10 nombres, initialisée à zéro, utilisez la commande suivante:

```{r}
a <- numeric(10)
a
```


Si vous souhaitez déterminer le type de données utilisé pour une variable, tapez la commande:

```{r}
typeof(a)
```


### Chaînes de caractères (String)

Vous pouvez également stocker des chaînes de caractères. Une chaîne de caractères est spécifiée en utilisant des guillemets. Les guillemets simples et doubles fonctionnent:

```{r}
a <- "bonjour"
a
b <- c ( "bonjour" , "toi" )
b [ 2 ]
```

Une chaîne de caractères contient bien des caractères

```{r}
typeof(a)
a=character (20)
a
```


### Facteurs (Factor)

R peut aussi stocker des données de type "facteur". Souvent, une expérience comprend différents niveaux d'une variable explicative (modalités). Par exemple, en examinant l'impact du dioxyde de carbone sur le taux de croissance d'un arbre, vous pouvez essayer d'observer comment différents arbres se développent lorsqu'ils sont exposés à différentes concentrations prédéfinies de dioxyde de carbone. Les différents niveaux sont appelés "modalités du facteurs".

Nous allons les données dans la dataframe "tree". Plusieurs variables du fichier sont des facteurs: 

```{r}
tree <- read.csv(file="trees91.csv",header=TRUE,sep=",");
names(tree)
typeof(tree$CHBR)
summary(tree)
summary(tree$CHBR)
```

Lorsque vous utilisez "summary" sur un facteur, il n'imprime pas le résumé en cinq points habituel, mais les modalités et leurs fréquences correspondantes.

Dans cet ensemble de données, plusieurs colonnes sont des facteurs, mais les chercheurs ont utilisé des nombres pour indiquer les différents niveaux. Par exemple, la première colonne, intitulée "C", est un facteur. Chaque arbre a été cultivé dans un environnement avec l'un des quatre niveaux possibles de dioxyde de carbone. Les chercheurs ont  qualifié ces quatre environnements en 1, 2, 3 et 4. Malheureusement, R ne peut pas déterminer tout seul qu'il s'agit de facteurs.

C'est un problème courant et il existe un moyen de dire à R de traiter la colonne "C" comme un ensemble de facteurs. Vous spécifiez qu'une variable est un facteur à l'aide de la commande factor. Dans l'exemple suivant, nous convertissons la colonne C en un facteur:

```{r}
tree$C
summary(tree$C)
tree$C <- factor(tree$C)
tree$C
levels(tree$C)
summary(tree$C)
```

Une fois qu'un vecteur est converti en facteur, alors R le traite différemment. Un ensemble de facteurs a un ensemble discret de valeurs possibles, et il n'est pas logique d'essayer de trouver des moyennes ou d'autres descriptions numériques. Une chose importante est le nombre de fois que chaque facteur apparaît, appelé "fréquences", qui est imprimé en utilisant la commande de résumé.



XXXX Comment ajouter un élément à une liste de facteur XXXX

XXXX Utiliser stringsasfactor=F dans read.csv si lXXXXX


### Matrice (matrix)

Une matrice contient différentes colonnes de même type 

```{r}
A = matrix( 
   c(2, 4, 3, 1, 5, 7), # the data elements 
   nrow=2,              # number of rows 
   ncol=3,              # number of columns 
   byrow = TRUE)        # fill matrix by rows 
 
A                      # print the matrix 
```

Un élément à la ligne m, colonne n de la matrice peut être accédé par :  A[m, n].

```{r}
A[2, 3] 
```

La ligne m entière peut être extraite par A[m, ].
```{r}
A[2, ] 
```

Et la colonne n entière par  A[,n]:
```{r}
A[, 3] 
```
On peut transposer, et même déconstruire une matrice. Attention il faut enregistrer le résultat dans un autre objet pour pouvoir le réutiliser. Si on a vraiment envie on peut même faire un chi2.

```{r}
t(A)
c(A)
B=c(A)
chisq.test(A)
```

### Table de données (data frame)

Un tableau de données (data frame) est un moyen de prendre plusieurs vecteurs de types différents et de les stocker dans la même variable. Les vecteurs peuvent être de tous types différents. Par exemple, une dataframe peut contenir plusieurs listes et chaque liste peut être une liste de facteurs, de chaînes ou de nombres.

Il existe différentes manières de créer et de manipuler des dataframes. Un exemple de création d'une dataframe est donné ci-dessous:


```{r}
a <- c(1,2,3,4)
b <- c(2,4,6,8)
levels <- factor(c("A","B","A","B"))
bubba <- data.frame(first=a,
                      second=b,
                      f=levels)
bubba
summary(bubba)
bubba$first
bubba$second
bubba$f
```

On peut donner des noms de lignes à la dataframe, ce qui est bien pratique pour accéder aux données.
  
```{r}
names(bubba)
names(bubba)=paste(names(bubba),"toto",sep=".")
row.names(bubba)=c("a","b","c","d")
bubba["a","first"]
bubba["a","first.toto"]
dim(bubba)
nrow(bubba)
ncol(bubba)
```  
  

XXXX quand l'on utile read csv on crée un objet de type data frame XXXXX




### Booléen (Boolean)

Un autre type de données important est le type logique, qui prend deux valeurs prédéfinies, TRUE ou FALSE :
 
```{r}
a = TRUE
typeof(a)
b = FALSE
typeof(b)
```

Les opérateurs logiques standards peuvent être utilisés:


|Operateur||
|---|---|
|< 	|moins que|
|> 	|super|
|<= 	|inférieur ou égal|
|>= 	|supérieur ou égal|
|== 	|égal à|
|!= 	|différent de|
| \|\| 	|ou|
|! 	|ne pas|
|&& |	et|


Notez qu'il existe une différence entre les opérateurs qui agissent sur les entrées dans un vecteur et le vecteur entier:

```{r}
a = c(TRUE,FALSE)
b = c(FALSE,FALSE)
a|b
a||b
```

XXXXX
> Quelle est la différence entre a|b et a||b ?

XXXX



Il existe un grand nombre de fonctions pour déterminer le type d'une variable. Par exemple, la fonction is.numeric peut déterminer si une variable est numérique:

```{r}
a = c(1,2,3)
is.numeric(a)
is.factor(a)
```

On pourra aussi convertir un type en un autre. 

```{r}
a = c(1,2,3)
is.numeric(a)
a=as.factor(a)
is.numeric(a)
```

##  Tables

XXX Tables de contingences ? XXXXXX

### Tables à une dimension

Les tableaux à une dimension ne sont pas l'exemple le plus intéressant, mais c'est un bon point de départ. Une façon de créer une table utilise la commande "table". 

```{r}
a <- factor(c("A","A","B","A","B","B","C","A","C"))
results <- table(a)
results
a
attributes(results)
summary(results)
```



### Tables à deux dimensions

Dans l'exemple ci-dessous, nous avons deux questions. Dans la première question, les réponses sont étiquetées «Jamais», «Parfois» ou «Toujours». Dans la deuxième question, les réponses sont intitulées «Oui», «Non» ou «Peut-être». L'ensemble des vecteurs "a" et "b", contiennent la réponse pour chaque question. Le troisième élément de "a" est la façon dont la troisième personne a répondu à la première question, et le troisième élément de "b" est la façon dont la troisième personne a répondu à la deuxième question.

```{r}
a <- c("Sometimes","Sometimes","Never","Always","Always","Sometimes","Sometimes","Never")
b <- c("Maybe","Maybe","Yes","Maybe","Maybe","No","Yes","No")
results <- table(a,b)
results
``` 


La commande table nous permet de faire un calcul très rapide, et nous pouvons immédiatement voir que deux personnes qui ont dit "Peut-être" à la première question ont aussi dit "Parfois" à la deuxième question.

Il est possible de saisir manuellement des tableaux. Vous entrez toutes les données dans une longue liste, mais dites à R de les diviser en un certain nombre de colonnes:

```{r}
sexsmoke<-matrix(c(70,120,65,140),ncol=2,byrow=TRUE)
rownames(sexsmoke)<-c("male","female")
colnames(sexsmoke)<-c("smoke","nosmoke")
sexsmoke <- as.table(sexsmoke)
sexsmoke
``` 

La commande matrix crée une matrice deux par deux. 
L'option "byrow=T" indique que les numéros sont d'abord remplis dans les lignes et que ncols = 2 indique qu'il y a deux colonnes.


# Opérations de base et descriptions numériques

Nous examinons certaines des opérations de base que vous pouvez effectuer sur des listes de nombres. 

## Opérations de base

Une fois que vous avez un vecteur (ou une liste de nombres) en mémoire, la plupart des opérations de base sont disponibles. La plupart des opérations de base agissent sur un vecteur entier et peuvent être utilisées pour effectuer rapidement un grand nombre de calculs avec une seule commande. Il y a une chose à noter, si vous effectuez une opération sur plus d'un vecteur, il est souvent nécessaire que les vecteurs contiennent tous le même nombre d'entrées.

Attention, parfois le calcul est effectué tout de même, vérifiez bien la taille de vos éléments dans R!!


```{r}
a <- c(1,2,3,4)
a
a + 5
a - 10
a*4
a/5
``` 
 
Nous pouvons sauvegarder les résultats dans un autre vecteur appelé b :

```{r}
b <- a - 10
b
``` 
  
Si vous voulez prendre la racine carrée,  le logarithme, etc.

```{r}
sqrt(a)
exp(a)
log(a)
exp(log(a))
``` 
  
En combinant les opérations et en utilisant des parenthèses, vous pouvez créer des expressions plus compliquées:

    
```{r}
c <- (a + sqrt(a))/(exp(2)+1)
c
``` 
  
Notez que vous pouvez faire les mêmes opérations avec des arguments vectoriels. Par exemple pour ajouter les éléments du vecteur a aux éléments du vecteur b, utilisez la commande suivante:

```{r}
a + b
``` 
  
L'opération est effectuée élément par élément. Notez que ceci est vrai pour presque toutes les fonctions de base. Vous pouvez donc rassembler toutes sortes d'expressions compliquées:

```{r}
a*b
a/b
(a+3)/(sqrt(1-b)*2-1)
``` 

  Attention, lorsque vous effectuez des opérations sur des vecteurs, ils sont effectués élément par élément. Tous les vecteurs dans une expression doivent donc avoir la même longueur. Si les longueurs des vecteurs diffèrent, vous pouvez recevoir un message d'erreur, ou pire, aucun message d'avertissement et des résultats imprévisibles:

```{r}
a <- c(1,2,3)
b <- c(10,11,12,13)
a+b
``` 
  
Lorsque vous travaillez dans R et que vous créez de nouveaux vecteurs, il peut être facile de perdre la trace des variables que vous avez définies. Pour obtenir une liste de toutes les variables qui ont été définies, utilisez la commande ls():

 
Enfin, gardez à l'esprit  les opérations de base fonctionnent presque toujours élément par élément mais il y a de rares exceptions à cette règle générale. Par exemple, si vous regardez le minimum de deux vecteurs en utilisant la commande min, vous obtiendrez le minimum de tous les chiffres. 


```{r}
a <- c(1,-2,3,-4)
b <- c(-1,2,-3,4)
min(a,b)
pmin(a,b)
``` 

## Descriptions numériques de base

Les commandes suivantes peuvent être utilisées pour obtenir la moyenne, la médiane, les quantiles, le minimum, le maximum, la variance et l'écart-type d'un ensemble de nombres:


```{r}
mean(tree$LFBM)
median(tree$LFBM)
quantile(tree$LFBM)
min(tree$LFBM)
max(tree$LFBM)
var(tree$LFBM)
sd(tree$LFBM)
``` 
 

Enfin, la commande summary affichera les valeurs min, max, mean, median et quantiles:
La commande de résumé est particulièrement agréable parce que si vous lui donnez une datafra:e, elle imprimera le résumé pour chaque vecteur:

```{r}
summary(tree)
``` 


## Opérations sur les vecteurs

Ici, nous regardons certaines commandes couramment utilisées qui effectuent des opérations sur des vecteurs Les commandes incluent les commandes sort , min , max et sum. Tout d'abord, la commande sort peut trier le vecteur donné dans l'ordre croissant ou décroissant:

```{r}
a = c(2,4,6,3,1,5)
b = sort(a)
c = sort(a,decreasing = TRUE)
a
b
c
``` 

Les commandes min et max trouvent les nombres minimum et maximum dans le vecteur:

```{r}
min(a)
max(a)
``` 

Enfin, la commande sum additionne les nombres dans le vecteur:

```{r}
sum(a)
``` 



#  Indexation dans les vecteurs

Ici, nous montrons comment utiliser la notation d'indexation de R pour sélectionner des éléments spécifiques dans un vecteur.

## Indexation avec des logiques

Nous donnons d'abord un exemple de la façon de sélectionner des éléments spécifiques dans un vecteur. La première étape consiste à définir un vecteur de données, et la seconde étape consiste à définir un vecteur constitué de valeurs logiques. Lorsque le vecteur de valeurs logiques est utilisé comme index, seuls les éléments correspondant aux variables évaluées TRUE sont renvoyés:


```{r}
a <- c(1,2,3,4,5)
b <- c(TRUE,FALSE,FALSE,TRUE,FALSE)
a[b]
max(a[b])
sum(a[b])
``` 

## Non disponible ou valeurs manquantes

Un problème commun concerne les entrées de données marquées NA ou non disponibles. Il existe une variable prédéfinie appelée NA qui peut être utilisée pour indiquer des informations manquantes. Le problème avec ceci est que certaines fonctions lancent une erreur si l'une des entrées dans les données est NA. Certaines fonctions vous permettent d'ignorer les valeurs manquantes grâce à des options spéciales:

```{r}
a <- c(1,2,3,4,NA)
a
sum(a)
sum(a,na.rm=TRUE)
``` 

La fonction is.na peut être utilisée pour trouver les données manquantes : NA pour "not available". L'opérateur logique "not" dans R est le !. Les éléments d'un vecteur qui sont "NA" peuvent être facilement supprimés:

```{r}
a <- c(1,2,3,4,NA)
is.na(a)
!is.na(a)
a[!is.na(a)]
b <- a[!is.na(a)]
b
``` 

### Indices avec expression logique

Toute expression logique peut être utilisée comme un index. Par exemple, vous pouvez supprimer ou retenir des entrées correspondant à des critères spécifiques. 

```{r}
a = c(6,2,5,3,8,2)
a
b = a[a<6]
b
tree[1:10,]
tree[,1:5]
tree[22,32]
tree[tree$CHBR=="A1",]
``` 

Pour un autre exemple, supposons que vous souhaitiez récupérer les valeurs d'un vecteur1 correspondant à deux modalités différentes d'un facteur dans un autre vecteur2:

```{r}
d = data.frame(one=as.factor(c('a','a','b','b','c','c')),
                two=c(1,2,3,4,5,6))
d
both = d$two[(d$one=='a') | (d$one=='b')]
both
``` 

Notez qu'un seul '|' a été utilisé dans l'exemple précédent. Il y a une différence entre '||' et '|'. Une barre unique effectuera une opération vectorielle, terme par terme, tandis qu'une barre double évaluera un seul résultat TRUE ou FALSE:

```{r}
(c(TRUE,TRUE))|(c(FALSE,TRUE))
(c(TRUE,TRUE))||(c(FALSE,TRUE))
(c(TRUE,TRUE))&(c(FALSE,TRUE))
(c(TRUE,TRUE))&&(c(FALSE,TRUE))
``` 
 

# Graphiques de base

Ceci est une introduction aux graphiques de base

## histogramme
 

Pour tracer un histogramme des données, lire le fichier w1.dat dans objet et utiliser la commande "hist" sur la colonne "vals"

```{r}
w1 <- read.csv(file="w1.dat",sep=",",head=TRUE)
hist(w1$vals)
hist(w1$vals,main="Distribution of w1",xlab="w1")
``` 

Comme vous pouvez le voir, R calculera automatiquement les intervalles à utiliser. Il y a beaucoup d'options pour déterminer comment couper les intervalles. Si vous souhaitez en savoir plus sur les options, consultez la page d'aide:

```{r}
help(hist)
hist(w1$vals,breaks=2)
hist(w1$vals,breaks=4)
hist(w1$vals,breaks=6)
``` 

 
 Vous pouvez également faire varier les limites de la zone tracée en utilisant l'option xlim. Cette option prend un vecteur avec deux entrées:

```{r}
hist(w1$vals,breaks=12,xlim=c(0,10))
hist(w1$vals,breaks=12,xlim=c(-1,2))
hist(w1$vals,breaks=12,xlim=c(0,2))
``` 

Vous devez toujours annoter vos graphiques et il existe plusieurs façons d'ajouter des titres et des libellés. Une façon est dans la commande hist elle-même:

```{r}
hist(w1$vals,
       main='Leaf BioMass in High CO2 Environment',
       xlab='BioMass of Leaves')
``` 

vous pouvez utiliser la commande title:

```{r}
hist(w1$vals,
       main='Leaf BioMass in High CO2 Environment',
       xlab='BioMass of Leaves')
title('Leaf BioMass in High CO2 Environment',xlab='BioMass of Leaves')
``` 

Notez que cela ajoute simplement le titre et les étiquettes et écrira au-dessus de tous les titres ou étiquettes que vous avez déjà.

Il n'est pas rare d'ajouter d'autres types de graphiques à un histogramme. Par exemple, l'une des options consiste à l'ajouter à un tracé qui a déjà été dessiné. Par exemple, vous pouvez avoir un histogramme avec un stripchart en haut. L'ajout du graphique peut vous donner une meilleure idée de la densité des données:

```{r}
hist(w1$vals,main='Leaf BioMass in High CO2 Environment',xlab='BioMass of Leaves',ylim=c(0,16))
stripchart(w1$vals,add=TRUE,at=15.5)
``` 


## Boxplots 

Une boîte à moustache fournit une représentation graphique de la médiane, des quartiles, du maximum et du minimum d'un ensemble de données. 

Nous utilisons d'abord le jeu de données w1 et regardons le boxplot de la colonne vals:

```{r}
boxplot(w1$vals)
``` 

Il s'agit d'un graphique très simple, et le titre et les étiquettes peuvent être spécifiés exactement de la même manière que dans hist:

```{r}
boxplot(w1$vals,
          main='Leaf BioMass in High CO2 Environment',
          ylab='BioMass of Leaves')
``` 

Notez que l'orientation par défaut est de tracer le boxplot verticalement. Pour cette raison, nous avons utilisé l'option ylab pour spécifier l'étiquette de l'axe. Il y a un grand nombre d'options pour cette commande. Pour voir plus d'options voir la page d'aide:


A titre d'exemple, vous pouvez spécifier que le boxplot soit tracé horizontalement:

```{r}
 boxplot(w1$vals,
          main='Leaf BioMass in High CO2 Environment',
          xlab='BioMass of Leaves',
          horizontal=TRUE)
``` 

L'option de tracer la boîte à l'horizontale peut être utilisée pour afficher une boîte à moustaches sur la même image qu'un histogramme. Vous devez spécifier l'option add, spécifier où placer le plot box en utilisant l'option at, et désactiver l'ajout d'axes en utilisant l'option axes: 

```{r}
 hist(w1$vals,main='Leaf BioMass in High CO2 Environment',xlab='BioMass of Leaves',ylim=c(0,16))
boxplot(w1$vals,horizontal=TRUE,at=15.5,add=TRUE,axes=FALSE)
``` 


Pour la deuxième partie sur les boxplots, nous allons travailler sur l'objet "tree", qui provient du fichier trees91.csv. Nous devons spécifier quelles colonnes sont des facteurs:

```{r}
tree <- read.csv(file="trees91.csv",sep=",",head=TRUE)
tree$C <- factor(tree$C)
tree$N <- factor(tree$N)
``` 

Nous pouvons tracer le boxplot pour la biomasse de la tige:


```{r}
boxplot(tree$STBM,
          main='Stem BioMass in Different CO2 Environments',
          ylab='BioMass of Stems')
``` 

mais les arbres ont été cultivés dans différents types d'environnements. La commande boxplot peut être utilisée pour tracer une boîte à moustaches distincte pour chaque niveau. 

```{r}
boxplot(tree$STBM~tree$C)
```

Notez que pour le niveau appelé "2", il y a quatre valeurs aberrantes qui sont représentées par des petits cercles. 



## Scatter Plots

Nous examinons la relation entre la biomasse de la tige (STBM) et la biomasse foliaire (LFBM).

La commande pour tracer chaque paire de points en tant que coordonnée x et y-coorindate est "plot:"

```{r}
plot(tree$STBM,tree$LFBM)
```

Il semble qu'il existe une forte association positive entre la biomasse dans les tiges d'un arbre et les feuilles de l'arbre. Cela semble être une relation linéaire. En fait, la corrélation entre ces deux ensembles d'observations est assez élevée: 

```{r}
cor(tree$STBM,tree$LFBM)
```

Pour en revenir à nos moutons, vous devriez toujours annoter vos graphiques. 

```{r}
plot(tree$STBM,tree$LFBM,
       main="Relationship Between Stem and Leaf Biomass",
       xlab="Stem Biomass",
       ylab="Leaf Biomass")
```



# Application sur un vrai jeu de données (chauves souris)

Le prix Ig Nobel est attribué chaque année dans différentes disciplines ; il est dédié aux chercheurs
dont les recherches "font rire, puis font réfléchir" (http://www.improbable.com/ig/winners/). Toutes les
études récompensées sont méthodologiquement correctes, même si leur sujet laisse parfois sourire.

> Quelle est votre étude préférée?

Le prix Ig Nobel de biologie a été attribué en 2010 à Libiao Zhang, Min Tan, Guangjian Zhu, Jian-
ping Ye, Tiyu Hong, Shanyi Zhou, Shuyi Zhang (Chine) et Gareth Jones (Royaume-Uni), qui ont montré
l’existence et étudié les comportements de fellation chez les chauves-souris de l’espèce C. sphinx. Ils ont filmé des chauves-souris de nuit et ont pu mettre en évidence ce comportement sexuel connu jusqu’alors uniquement chez les primates (bonobos, orang-outan et homme) : les femelles de cette chauve-souris, pendant l’accouplement, peuvent se positionner de manière à lécher la base du sexe du mâle. Le jeu de données analysé porte sur les temps relatifs de copulation et de fellation. Chaque ligne représente un accouplement, pour lequel 3 variables ont été mesurées :

XXX ou est le jeu de données ?XXX


* licking vaut 1 si le comportement de léchage a été observé, 0 dans le cas contraire ;
* time licking mesure le temps, en secondes, durant lequel le comportement de léchage est observé
pendant l’accouplement ;
* time copulation mesure le temps total, en secondes, qu’a duré l’accouplement, léchage inclus.

XXXX

> Importer le jeu de données


XXX

> Quelle commande permet d’obtenir l’affichage des 7 premières lignes du jeu de données?

```{r}
## Ici il faut faire quelque chose !! 
```

> Quelle commande permet d’obtenir le nombre de lignes et de colonnes de votre table ?

```{r}
## Ici aussi (etc)
```

> Quelle commande permet d’obtenir le nom des colonnes de votre table ?

> Quelle commande permet d’obtenir la moyenne des temps de copulation pour toutes les données?

> Quelles commandes permettent de créer deux nouveaux tableaux, un pour chaque comportement ?

> Quelle commande permet de selectionner les lignes tel que le temps de copulation soit supérieur à 100?

> Quelle commande permet de selectionner les lignes tel que le temps de copulation soit supérieur à 200 et le temps de léchage inférieur ou égale à 20?

> Quelle commande permet de récupérer le temps de copulation dans le cas où le temps de léchage est supérieur à 20?

> Quelle commande permet d’obtenir la moyenne des temps de copulation par comportement?

> Donner deux commandes permettant de savoir dans combien de cas le comportement de léchage a été observé.

Dans l’étude, les chercheurs ont commencé par regarder s’il existait une relation entre le temps de léchage et le temps de copulation total.

> Donner la commande permettant de tracer ce graphique, sans oublier les légendes.

> Rajouter une droite de régression sur ce graphique.

Le coefficient de corrélation entre le temps de léchage et le temps de copulation (calculé sur l’ensemble des données) vaut R = 0.86, et un test statistique montre que cette valeur est significativement différente de 0.

> Recalculer la valeur du coefficient de corrélation et refaire le test. Pourquoi les chercheurs ne peuvent-ils pas en déduire que le phénomène de léchage est la cause d’un temps de copulation plus long ?

> Quel graphe feriez-vous pour illustrer la différence des temps de copulation entre les couples où l’on observe le phénomène de léchage et les couples où on ne l’observe pas ? Donner la (ou les) commande(s) correspondante(s).

Article original: http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0007595
Vidéo : http://sciences.blog.lemonde.fr/2009/11/04/la-vie-sexuelle-agitee-des-chauves-souris/

PS: l’IgNobel de 2013 était peut-être plus poétique : "Dung beetles use the milky way for orientation"
(http://www.sciencedirect.com/science/article/pii/S0960982212015072).

# Graphiques intermédiaires

La section est divisée en trois sections. L'objectif de la première section est de représenter graphiquement les données continues. L'objectif de la deuxième section est de représenter graphiquement des données discrètes. La troisième section offre quelques options diverses utiles dans divers contextes.

## Données continues


Dans les exemples ci-dessous, un ensemble de données est défini en utilisant le générateur de nombres aléatoires normalement distribués de R.

```{r}
x <- rnorm(10,sd=5,mean=20)
y <- 2.5*x-1.0+rnorm(10,sd=9,mean=0)
cor(x,y)

```


### Plusieurs jeux de données sur un graphique

Une tâche courante consiste à tracer plusieurs ensembles de données sur le même graphique. Dans de nombreuses situations, la méthode consiste à créer le plot initial, puis à ajouter des informations supplémentaires. Par exemple, pour tracer des données bivariées, la commande plot est utilisée pour initialiser et créer le tracé. La commande points peut ensuite être utilisée pour ajouter des données supplémentaires au tracé.

Définissez d'abord un ensemble de nombres aléatoires, puis tracez-les. (Ce même jeu de données est utilisé dans tous les exemples ci-dessous.)

```{r}
x <- rnorm(10,sd=5,mean=20)
y <- 2.5*x - 1.0 + rnorm(10,sd=9,mean=0)
cor(x,y)
plot(x,y,xlab="Independent",ylab="Dependent",main="Random Stuff")
x1 <- runif(8,15,25)
y1 <- 2.5*x1 - 1.0 + runif(8,-6,6)
points(x1,y1,col=2)
```

Notez que dans l'exemple précédent, la couleur du second ensemble de points de données est définie à l'aide de l'option col. Vous pouvez essayer différents nombres pour voir quelles couleurs sont disponibles. Notez également que dans l'exemple ci-dessus, les points sont représentés par des cercles. Le symbole utilisé peut être changé en utilisant l'option pch .

```{r}
x2 <- runif(8,15,25)
y2 <- 2.5*x2 - 1.0 + runif(8,-6,6)
plot(x,y,xlab="Independent",ylab="Dependent",main="Random Stuff")
points(x2,y2,col=3,pch=2)
```


Une autre option utile consiste à ajouter une légende. Cela peut être fait avec la commande legend. Les options de la commande, dans l'ordre, sont les coordonnées x et y sur le tracé pour placer la légende suivie d'une liste d'étiquettes à utiliser. Il existe un grand nombre d'autres options, utilisez donc help (légende) pour voir plus d'options. Par exemple, une liste de couleurs peut être donnée avec l'option col , et une liste de symboles peut être donnée avec l'option pch .

```{r}
plot(x,y,xlab="Independent",ylab="Dependent",main="Random Stuff")
points(x1,y1,col=2,pch=3)
points(x2,y2,col=4,pch=5)
legend(14,70,c("Original","one","two"),col=c(1,2,4),pch=c(1,3,5))
```

### Barres d'erreur

Une autre tâche courante consiste à ajouter des barres d'erreur à un ensemble de points de données. Cela peut être accompli en utilisant la commande arrows. La commande arrows prend deux paires de coordonnées, c'est-à-dire deux paires de valeurs x et y . La commande dessine ensuite une ligne entre chaque paire et ajoute une "tête de flèche" avec une longueur et un angle donnés. 

```{r}
plot(x,y,xlab="Independent",ylab="Dependent",main="Random Stuff")
xHigh <- x
yHigh <- y + abs(rnorm(10,sd=3.5))
xLow <- x
yLow <- y - abs(rnorm(10,sd=3.1))
arrows(xHigh,yHigh,xLow,yLow,col=2,angle=90,length=0.1,code=3)
```


Notez que le code d'option est utilisé pour spécifier où les barres sont dessinées. Sa valeur peut être 1, 2 ou 3. 

### Plusieurs graphiques sur une image

Les graphiques sont disposés dans un tableau où le nombre par défaut de lignes et de colonnes est un (un graphique par page par défaut). Le paramètre mfrow est un vecteur avec deux entrées. La première entrée est le nombre de lignes d'images. La deuxième entrée est le nombre de colonnes. Dans l'exemple ci-dessus, les graphiques ont été disposées en une rangée avec deux graphiques

```{r}
par(mfrow=c(2,3))
numberWhite <- rhyper(400,4,5,3)
numberChipped <- rhyper(400,2,7,3)
boxplot(numberWhite,main="first plot")
boxplot(numberChipped,main="second plot")
plot(jitter(numberWhite),jitter(numberChipped),xlab="Number White Marbles Drawn",
       ylab="Number Chipped Marbles Drawn",main="Pulling Marbles With Jitter")
hist(numberWhite,main="fourth plot")
hist(numberChipped,main="fifth plot")
mosaicplot(table(numberWhite,numberChipped),main="sixth plot")
```



### Tracés de densité

Il y a des moments où vous ne voulez pas tracer des points spécifiques mais souhaitez tracer une densité. Cela peut être fait en utilisant la commande smoothScatter .

```{r}
numberWhite <- rhyper(30,4,5,3)
numberChipped <- rhyper(30,2,7,3)
smoothScatter(numberWhite,numberChipped,
             xlab="White Marbles",ylab="Chipped Marbles",main="Drawing Marbles")
```


### Colorier des régions

Une région ombrée peut être tracée en utilisant la commande polygone. La commande polygone prend une paire de vecteurs, x et y , et ombre la région délimitée par les paires de coordonnées. Dans l'exemple ci-dessous, un carré bleu est dessiné. Les sommets sont définis à partir de la partie inférieure gauche. Cinq paires de points sont données car le point de départ et le point final sont les mêmes.

```{r}
x = c(-1,1,1,-1,-1)
y = c(-1,-1,1,1,-1)
plot(x,y)
polygon(x,y,col='blue')
```

Un exemple plus compliqué est donné ci-dessous. Dans cet exemple, la région de rejet pour un test d'hypothèse du côté droit est tracée, et elle est ombrée en rouge. 

```{r}
stdDev <- 0.75;
x <- seq(-5,5,by=0.01)
y <- dnorm(x,sd=stdDev)
right <- qnorm(0.95,sd=stdDev)
plot(x,y,type="l",xaxt="n",ylab="p",
       xlab=expression(paste('Assumed Distribution of ',bar(x))),
       axes=FALSE,ylim=c(0,max(y)*1.05),xlim=c(min(x),max(x)),
       frame.plot=FALSE)
axis(1,at=c(-5,right,0,5),
       pos = c(0,0),
       labels=c(expression(' '),expression(bar(x)[cr]),expression(mu[0]),expression(' ')))
axis(2)
xReject <- seq(right,5,by=0.01)
yReject <- dnorm(xReject,sd=stdDev)
polygon(c(xReject,xReject[length(xReject)],xReject[1]),
          c(yReject,0, 0), col='red')
```


Les axes sont dessinés séparément. Ceci est fait en supprimant d'abord le tracé des axes dans la commande plot , et l'axe horizontal est dessiné séparément. Notez également que la commande expression est utilisée pour tracer un caractère grec et également produire des indices.


## Données discrètes


Dans les exemples ci-dessous, un ensemble de données est défini à l'aide du générateur de nombres aléatoires hypergéométriques de R.

```{r}
numberWhite <- rhyper ( 30 , 4 , 5 , 3 )
numberChipped <- rhyper ( 30 , 2 , 7 , 3 )
```

### Barplot

La commande plot tentera de produire les graphiques appropriés en fonction du type de données. Les données définies ci-dessus, cependant, sont des données numériques. La commande as.factor est utilisée pour convertir les données en facteurs et garantit que R les traite comme des données discrètes.

```{r}
numberWhite <- rhyper(30,4,5,3)
numberWhite <- as.factor(numberWhite)
plot(numberWhite)
```

Dans ce cas, R produira un barplot. La commande barplot peut également être utilisée pour créer un barplot. La commande barplot nécessite cependant un vecteur de hauteurs, et vous ne pouvez pas simplement lui donner les données brutes. Ces valeurs peuvent être facilement calculées à l'aide de la commande table.


```{r}
numberWhite <- rhyper(30,4,5,3)
totals <- table(numberWhite)
totals
barplot(totals,main="Number Draws",ylab="Frequency",xlab="Draws")
```


Dans l'exemple précédent, la commande barplot est utilisée pour définir le titre du tracé et les libellés des axes. Les étiquettes sur les graduations pour l'axe horizontal sont générées automatiquement à l'aide des étiquettes de la table. Vous pouvez modifier les étiquettes en définissant les noms de ligne de la table.

```{r}
numberWhite <- rhyper(30,4,5,3)
totals <- table(numberWhite)
rownames(totals) <- c("none","one","two","three")
barplot(totals,main="Number Draws",ylab="Frequency",xlab="Draws")
```

L'ordre des fréquences est le même que celui de la table. Si vous modifiez l'ordre dans le tableau, cela changera la façon dont il apparaît dans le graphique à barres. Par exemple, si vous souhaitez organiser les fréquences dans l'ordre décroissant, vous pouvez utiliser la commande de tri avec l'option décroissante.

```{r}
barplot(sort(totals,decreasing=TRUE),main="Number Draws",ylab="Frequency",xlab="Draws")
```

Les fonctions d'indexation de R peuvent être utilisées pour changer l'ordre des fréquences manuellement.

```{r}
totals
sort(totals,decreasing=TRUE)
numberWhite
totals[c(3,1,4,2)]
numberWhite
barplot(totals[c(3,1,4,2)])
```


## Imprimer dans un fichier

Il existe plusieurs façons d'imprimer un tracé dans un fichier. 
Dans l'exemple ci-dessous, la fenêtre en cours est imprimée dans un fichier png appelé "hist.png" d'une largeur de 200 pixels.

```{r,eval=FALSE}
x = rnorm(100)
hist(x)
dev.print(device=png,width=200,"hist.png")
```


Une autre façon d'imprimer dans un fichier consiste à créer un périphérique. Une fois le périphérique créé, les différentes commandes de traçage sont données, puis le périphérique est désactivé pour écrire dans le fichier.

```{r}
png(file="hist.png")
hist(x)
rug(x,side=1)
dev.off()
```
 
 

# Gestion des données

Nous examinons ici certaines tâches courantes qui se présentent lors du traitement des données. Ces tâches vont de l'assemblage de différents ensembles de données aux façons d'appliquer des fonctions à différentes parties des ensembles de données. Les fonctions sont couramment utilisées dans une grande variété de circonstances pour un certain nombre de raisons différentes. 

## Ajout de données

Lorsque vous avez plus d'un ensemble de données, vous pouvez les combiner. Vous pouvez regrouper différents ensembles de données en les combinant par ligne (rbind) ou par colonnes (cbind). Le premier exemple montre cela avec deux dataframes. Les arguments des fonctions peuvent prendre n'importe quel nombre d'objets. Nous n'en utilisons que deux ici pour simplifier la démonstration. Il est important de noter que lorsque vous regroupez des tables par lignes, les noms des objets dans les tables doivent être identiques.

```{r,eval=FALSE}
a <- data.frame(one=c( 0, 1, 2),two=c("a","a","b"))
b <- data.frame(one=c(10,11,12),two=c("c","c","d"))
a
b
v <- rbind(a,b)
typeof(v)
[1] "list"
v
w <- cbind(a,b)
typeof(w)
w
names(w) = c("one","two","three","four")
w
```


Les mêmes commandes fonctionnent également avec des vecteurs et des matrices.

```{r,eval=FALSE}
A = matrix(c( 1, 2, 3, 4, 5, 6),ncol=3,byrow=TRUE)
A
B = matrix(c(10,20,30,40,50,60),ncol=3,byrow=TRUE)
B

V <- rbind(A,B)
typeof(V)
V
W <- cbind(A,B)
typeof(W)
```

Parfois, on veut faire une jointure sur une seule colonne. Dans ce cas, utiliser la fonction "merge". Prenez le temps d'observer son comportement.

```{r,eval=FALSE}
a <- data.frame(one=c( 0, 1, 2),two=c("a","a","b"))
b <- data.frame(three=c(10,11,12,4),two=c("c","c","d","a"))
rbind(a,b)
w=merge(a,b,by.x="two",by.y="two")
w
w=merge(a,b,by.x="two",by.y="two",all.x=T,all.y=T)
w
```



## Application de fonctions sur des éléments de données

Les différentes versions des commandes apply permettent de prendre une fonction et d'exécuter une opération sur chaque partie des données. Il existe une grande variété de ces commandes, mais nous n'en examinons que deux. Le premier ensemble, lapply et sapply, est utilisé pour appliquer une fonction à chaque élément d'une liste. Le deuxième, tapply, est utilisé pour appliquer une fonction sur chaque ensemble divisé par un ensemble donné de facteurs.

### Opérations sur les listes et les vecteurs

Tout d'abord, la commande lapply est utilisée pour prendre une liste d'éléments et effectuer une fonction sur chaque membre de la liste. Autrement dit, la liste comprend un certain nombre d'objets différents. Vous voulez effectuer une opération sur chaque objet de la liste. Vous pouvez utiliser lappply pour indiquer à R de parcourir chaque élément de la liste et d'effectuer l'action souhaitée sur chaque élément.

Dans l'exemple suivant, une liste est créée avec trois éléments. Le premier est un ensemble de nombres générés aléatoirement avec une distribution normale. Le second est un ensemble de nombres générés aléatoirement avec une distribution exponentielle. Le dernier est un ensemble de facteurs. Un résumé est ensuite effectué sur chaque élément de la liste.

```{r,eval=FALSE}
x <- list(a=rnorm(200,mean=1,sd=10),
            b=rexp(300,10.0),
            c=as.factor(c("a","b","b","b","c","c")))
lapply(x,summary)
```

La commande lapply retourne une liste. Les entrées de la liste portent le même nom que les entrées de la liste qui lui est transmise en entrée. Les valeurs de chaque entrée sont les résultats de l'application de la fonction. La fonction sapply est similaire, mais la différence est qu'elle essaie de transformer le résultat en un vecteur ou une matrice si possible. Si cela n'a pas de sens, alors il retourne une liste comme la commande lapply . 

```{r,eval=FALSE}
x <- list(a=rnorm(8,mean=1,sd=10),b=rexp(10,10.0))
x
val <- lapply(x,mean)
typeof(val)
val
val$a
val$b
other <- sapply(x,mean)
typeof(other)
other
other[1]
other[2]
```



### Opérations groupées par modalités d'un facteur

La fonction tapply prend une liste de données, généralement un vecteur, un facteur, et une fonction. Il appliquera ensuite la fonction à chaque sous-ensemble de données correspondant à chaque modalité du facteur.

```{r,eval=FALSE}
val <- data.frame(a=c(1,2,10,20,5,50),
                    b=as.factor(c("a","a","b","b","a","b")))
val
result <- tapply(val$a,val$b,mean)
typeof(result)
result
result[1]
result[2]
result <- tapply(val$a,val$b,summary)
typeof(result)
result
result$a
```


# Introduction à la programmation

## Instructions

### if 

L'exécution conditionnelle est disponible en utilisant l'instruction if. 

```{r}
x = 0.1
if( x < 0.2)
  {
     x <- x + 1
     cat("increment that number!\n")
  }
x
```

L'instruction else peut être utilisée pour spécifier une autre option. Dans l'exemple ci-dessous, notez que l'instruction else doit être sur la même ligne que l'accolade de fin pour le bloc if précédent.


```{r}
x = 2.0
if ( x < 0.2)
 {
    x <- x + 1
    cat("increment that number!\n")
 } else
 {
    x <- x - 1
    cat("nah, make it smaller.\n");
 }
x
```


Enfin, les instructions if peuvent être enchaînées.

```{r}
x = 1.0
if(x < 0.2)
{
    x <- x + 1
    cat("increment that number!\n")
} else if (x < 2.0)
{
   x <- 2.0*x
   cat("not big enough!\n")
} else
{
    x <- x - 1
    cat("nah, make it smaller.\n");
}
x
```

### for

La boucle for peut être utilisée pour répéter un ensemble d'instructions.

Un exemple est donné ci-dessous:

```{r}
for(lupe in seq(0,1,by=0.3))
{
    cat(lupe,"\n");
}
x <- c(1,2,4,8,16)

for(loop in x)
{
    cat("value of loop: ",loop,"\n");
}
```

break est utilisé pour arrêter l'execution de la boucle. 

```{r}
x <- rnorm(5)
x
for(lupe in x)
 {
     if (lupe > 2.0)
         next

     if( (lupe<0.6) && (lupe > 0.5))
        break

    cat("The value of lupe is ",lupe,"\n");
 }
```

### while

La boucle while peut être utilisée pour répéter une série d'instructions, et elle est souvent utilisée lorsque vous ne savez pas à l'avance à quelle fréquence les instructions seront exécutées. 

```{r}
lupe <- 1;
x <- 1
while(x < 4)
 {
    x <- rnorm(1,mean=2,sd=3)
    cat("trying this value: ",x," (",lupe," times in loop)\n");
    lupe <- lupe + 1
 }
```


### répéter les instructions

La boucle de répétition est similaire à la boucle while. La différence est que la boucle est réalisée au moins une fois. while ne lancera la boucle que si la condition est vraie la première fois qu'elle est évaluée. Une autre différence est que vous devez spécifier explicitement quand arrêter la boucle en utilisant la commande break .

C'est-à-dire que vous devez exécuter l'instruction break pour sortir de la boucle. 

```{r}
repeat
{
    x <- rnorm(1)
    if(x < -2.0) break
}
x
```



## Fonctions

Pour définir une fonction, vous l'affectez à un nom, et la fonction mot-clé est utilisée pour indiquer le début de la fonction et sa liste d'arguments. La dernière ligne de la fonction est ce qui est retourné. Ainsi, dans l'exemple ci-dessus, la moyenne des nombres est renvoyée.


```{r}

newDef <- function(a,b)
 {
     x = runif(10,a,b)
     mean(x)
 }
newDef(-1,1)

newDef
function(a,b)
{
   x = runif(10,a,b)
   mean(x)
}
x <- newDef(0,1)
x

```

Les arguments sont transmis dans l'ordre: R essaiera de faire correspondre les arguments nommés et de faire correspondre le reste de gauche à droite. Ils peuvent être spécifiés explicitement, cependant.


```{r} 
newDef(b=10,a=1)
newDef(10,1)
```

Une autre tâche courante consiste à avoir une fonction qui renvoie plusieurs éléments. Cela peut être accompli en renvoyant une liste d'éléments. Les objets dans une liste peuvent être accédés en utilisant la même notation $ utilisée pour les trames de données.


```{r}
c = c(1,2,3,4,5)
sample <- function(a,b)
{
  value = switch(a,"median"=median(b),"mean"=mean(b),"variance"=var(b))
  largeVals = length(c[c>1])
  list(stat=value,number=largeVals)
}
result <- sample("median",c)
result
result$stat
result$number
```

Un autre problème potentiel peut survenir lors de l'utilisation d'une fonction dans R. Si une variable précédemment indéfinie apparaît, R regardera la liste des arguments de la fonction. Ensuite, il regardera dans l'espace de travail actuel. Si vous ne faites pas attention, R trouvera la valeur à un endroit où vous ne l'attendez pas, et votre fonction retournera une valeur qui n'est pas correcte. Soyez très prudent sur les noms des variables, en particulier lorsque vous utilisez des fonctions.


## Exécuter un fichier

### Exécuter les commandes dans un fichier

Un ensemble de commandes R peut être enregistré dans un fichier, puis exécuté comme si vous l'aviez tapé depuis la ligne de commande. La commande source est utilisée pour lire le fichier et exécuter les commandes dans la même séquence que celle donnée dans le fichier.

```{r, eval=FALSE} 
source('file.R')
``` 
 
Si vous générez simplement le fichier, les commandes ne sont pas imprimées et les résultats des commandes ne sont pas imprimés. Cela peut être remédié en utilisant les options echo , print.eval et verbose.

Certains exemples sont donnés en supposant qu'un fichier, simpleEx.R , se trouve dans le répertoire courant. Le contenu du fichier est donné ci-dessous:

```{r}
 # Define a variable.
x <- rnorm(10)

# calculate the mean of x and print out the results.
mux = mean(x)
cat("The mean of x is ",mean(x),"\n")

# print out a summary of the results
summary(x)
cat("The summary of x is \n",summary(x),"\n")
print(summary(x))
```

Le fichier montre également l'utilisation de # pour spécifier des commentaires. Tout ce qui suit le # est ignoré. En outre, le fichier illustre l'utilisation de cat et print pour envoyer les résultats à la sortie standard. 
 


# Application sur un vrai jeu de données (lézards)


Le  lézard des murailles (\textit{Podarcis muralis}) est très commun en Europe. 
Son dos est d'une ennuyeuse couleur brune, probablement pas très visible des prédateurs. Par contre, le ventre des mâles peut prendre des couleurs fabuleuses. Tous les lézards muraux n'ont pas la même couleur, certains sont oranges, d'autres blancs ou jaunes. Les chercheurs ont récemment proposé que ces couleurs ont une fonction dans la signalisation sociale. Le lézard pourrait garder ses «vraies couleurs» cachées, loin des regards indiscrets des prédateurs, et les montrer aux autres lézards au moment approprié. 

La selection sexuelle est l'un des principaux processus inpliqués dans l'emergence et le maintien des polymorphismes avec des variations de couleurs dans de nombreux taxa. Si c'est le cas ici, on s'attend à ce que l'intensité de la sélection sexuelle dans les populations soit corrélée avec l'importance du polymorphisme dans les populations. 



Ici vous allez tester si l'intensité de la selection sexuelle, estimée à partir du sex ratio, prédit la diversité des morphes chez \textit{Podarcis muralis}.

![Podarcis muralis](morphs.jpg){ width=50% }


> Importer le jeu de données contenu dans "lezard.xlsx" et afficher les 5 premières lignes.

```{r, eval=FALSE} 
# A vous de jouer
``` 

Chacune des lignes représente une population où des individus ont été capturés. Le nombre de mâles, de femelles ainsi que le nombre de morphes observés a été répertorié. La colonne "richness" correspond au nombre de morphes dans la population et la colonne "eveness" correspond à la « régularité » de la répartition du nombre d'individus entre les morphes.


> Calculer le nombre de populations (colonne "poblacio" dans la table), le nombre total de femelles, le nombre total de mâles, le nombre total d'individus
  
```{r, eval=FALSE} 
# A vous de jouer (etc)
``` 


> Construire une nouvelle colonne contenant le sex ratio pour chacune des populations. Quels sont le minimum, la moyenne et le maximum  des sex ratio observés dans les populations ? 

$$ Sex ratio = \frac{Nb_{male}}{Nb_{femelle}} $$



> Restreindre votre jeu de données aux populations qui ont 50 lézards ou plus. Quelles populations passent le seuil ?

> Représenter en fonction du nombre de morphes (colonne "richness") la distribution des sex ratio. Qu'est ce que vous observez ?

> Représenter la « régularité » de la répartition du nombre d'individus entre les morphes (eveness) en fonction du sex ratio. Ajouter sur le graphe une droite de tendance. Que pouvez vous conclure ?

> Importer maintenant le jeu de données contenu dans "lezard2.csv". Il contient les caractéristiques (populations, morph, sexe) de chaque individu. Calculer le nombre de morphe pour chacun des sexes par population.

L'indice de shannon est un indice permettant de mesurer la diversité spécifique. 
Sa formule est:

$$ S = - \sum \limits_{i=1}^n p_i ln(p_i)$$ avec $n$ le nombre de morphes dans la population et $p_i$  la proportion du $i^{eme}$ morphe dans la population

> Faire une fonction pour calculer cet indice puis calculez-le pour chacune des populations.

> Représenter l'indice de shannon en fonction du sex ratio. Ajouter sur le graphe une droite de tendance. Que pouvez vous conclure ?

> Faire de-même en calculant l'indice de shannon par sexe. Que pouvez vous conclure ?

